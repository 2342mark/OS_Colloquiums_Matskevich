# Микро Коллоквиум: Реализация шаблона проектирования «Посетитель» для композита файловой системы с поддержкой многопоточности и ортогональной стратегией синхронизации

---

## Введение

В данной работе реализуется паттерн **Visitor (Посетитель)** для обхода и обработки элементов **композитной структуры**, моделирующей файловую систему.

Композит состоит из трёх типов узлов (нодов):

* **Диск** — корневой узел, содержащий папки и файлы
* **Папка** — может содержать другие папки и файлы
* **Файл** — листовой элемент, возможны разные типы файлов (например, текстовый, бинарный)

Ключевые задачи:

* Реализовать паттерн Visitor для обхода всех нодов с разной логикой для каждого типа
* Обеспечить безопасную работу в многопоточной среде с использованием **ортогональной стратегии синхронизации**
* Покрыть код модульными (Unit) и интеграционными (End-to-End) тестами для подтверждения корректности синхронизации и работы

---

## Теоретическая часть

### 1. Шаблон проектирования «Посетитель»

**Определение:**
Visitor позволяет определить новую операцию над элементами структуры без изменения классов этих элементов.

**Суть:**

* Элементы структуры (Component) реализуют метод `accept(Visitor&)`
* Visitor содержит набор перегруженных методов `visit` для каждого типа элемента
* При обходе структуры вызывается соответствующий метод посетителя для каждого элемента

**Преимущества:**

* Разделение алгоритмов и структуры
* Добавление новых операций без модификации элементов
* Улучшение модульности и расширяемости кода

**Пример интерфейсов:**

```cpp
class Disk;
class Folder;
class File;

class Visitor {
public:
    virtual void visit(Disk& disk) = 0;
    virtual void visit(Folder& folder) = 0;
    virtual void visit(File& file) = 0;
};
```

```cpp
class Node {
public:
    virtual void accept(Visitor& visitor) = 0;
    virtual ~Node() {}
};
```

---

### 2. Композит (Composite)

**Определение:**
Композит — структурный паттерн, позволяющий объединять объекты в древовидные структуры и работать с ними одинаково.

**В нашем случае:**

* `Disk` и `Folder` — Composite-узлы, хранящие дочерние элементы
* `File` — листовые узлы

**Особенности:**

* Единый интерфейс `Node`
* Рекурсивный обход и обработка

---

### 3. Многопоточность и безопасность данных

Работа с файловой системой в многопоточном режиме требует корректной синхронизации для предотвращения гонок данных и неконсистентных состояний.

---

### 4. Ортогональная стратегия синхронизации

**Концепция:**
Синхронизация реализуется через параметр шаблона — стратегию, которая определяет способ блокировки.

**Примеры стратегий:**

* NoLock — отсутствие синхронизации (для однопоточного режима)
* MutexLock — классический мьютекс
* SpinLock — быстрая блокировка на короткие критические секции

**Преимущества:**

* Гибкость — можно подставлять разные стратегии без изменения основного кода
* Повышение повторного использования и тестируемости

---

### 5. Структура решения

| Компонент          | Назначение                                         |
| ------------------ | -------------------------------------------------- |
| Node               | Абстрактный интерфейс всех нодов                   |
| Disk, Folder, File | Конкретные реализации компонентов файловой системы |
| Visitor            | Абстрактный интерфейс посетителя                   |
| ConcreteVisitor    | Конкретная реализация логики обхода/обработки      |
| SyncPolicy         | Шаблонные стратегии синхронизации                  |

---

## Практическая часть

### 1. Интерфейс и классы нодов

* Каждый нод реализует метод `accept(Visitor&)`, вызывающий соответствующий `visit`
* Composite-узлы хранят контейнер дочерних элементов (например, `std::vector<std::shared_ptr<Node>>`)
* Добавлены методы для добавления/удаления дочерних нодов

### 2. Посетитель

* Конкретный посетитель реализует методы `visit` для каждого типа нода
* Логика посетителя может быть: подсчёт файлов, сбор информации, выполнение операций

### 3. Синхронизация

* Используется шаблонный параметр для политики синхронизации
* В критических местах доступа к структуре применяется стратегия блокировки
* Для защиты внутреннего состояния и операций добавления/удаления/обхода

### 4. Многопоточная работа

* Обход и операции могут выполняться параллельно из нескольких потоков
* Обеспечивается потокобезопасный доступ и консистентность данных
* Используются стандартные средства C++11 и выше (`std::thread`, `std::mutex`, `std::atomic` и т.д.)

---

## Тестирование

### 1. Unit-тесты

* Проверка корректности реализации `accept` и `visit` для каждого типа
* Тестирование добавления и удаления элементов композита
* Проверка корректности вызова методов посетителя
* Тестирование корректности работы стратегий синхронизации (например, без гонок)

### 2. End-to-End тесты

* Многопоточный обход большой структуры с параллельными модификациями
* Проверка целостности и корректности результата после выполнения в многопоточном режиме
* Тестирование на гонки данных с помощью инструментов (например, Thread Sanitizer)

---

## Пример использования

```cpp
// Создание структуры
auto disk = std::make_shared<Disk>();
auto folder = std::make_shared<Folder>();
auto file1 = std::make_shared<File>("file1.txt");
auto file2 = std::make_shared<File>("file2.bin");

disk->add(folder);
folder->add(file1);
disk->add(file2);

// Создание посетителя с MutexLock синхронизацией
using SyncPolicy = MutexLock;

ConcreteVisitor<SyncPolicy> visitor;
disk->accept(visitor);

// Многопоточное выполнение обхода
std::thread t1([&]() { disk->accept(visitor); });
std::thread t2([&]() { folder->accept(visitor); });
t1.join();
t2.join();
```

---

## Итоги и рекомендации

* Реализация Visitor позволяет легко расширять операции над файловой системой без изменения классов нодов
* Композит даёт единый интерфейс для работы с древовидной структурой
* Ортогональная стратегия синхронизации обеспечивает гибкость и безопасность многопоточного доступа
* Покрытие тестами гарантирует отсутствие ошибок синхронизации и корректность логики

---
