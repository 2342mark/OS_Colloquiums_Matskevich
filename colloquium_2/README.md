# Коллоквиум 2: Разработка Singleton DP на базе ортогональных стратегий

## Введение

**Singleton** — один из наиболее известных паттернов проектирования. Он гарантирует существование единственного экземпляра класса и предоставляет глобальную точку доступа к нему.

Современная реализация паттерна требует учитывать:

* многопоточность
* возможность настройки поведения
* безопасность и эффективность

Поэтому в данном коллоквиуме задача — реализовать **Singleton на базе ортогональных стратегий** по методике из **6 главы книги Андрея Александреску «Modern C++ Design»**.

---

## Теоретическая часть

### Что такое Singleton

**Singleton (Одиночка)** — это поведенческий паттерн, который:

* ограничивает создание экземпляра одного объекта
* предоставляет к нему глобальную точку доступа

**Когда применять:**

* для объектов, к которым должен быть единый доступ: конфигурации, логгеры, менеджеры соединений, и пр.

---

### Проблемы классического Singleton

1. **Глобальные данные** — могут быть изменены из любого места.
2. **Проблемы многопоточности** — нужно синхронизировать создание экземпляра.
3. **Сложность тестирования** — Singleton сложно мокать и подменять.
4. **Жёсткая связность** — использование глобального состояния нарушает SRP и DIP.

---

### Ортогональные стратегии (Policy-based Design)

**Ортогональные стратегии** — это набор взаимозаменяемых политик, определяющих аспекты поведения класса.

**Преимущества:**

* максимальная гибкость
* независимость стратегий (ортогональность)
* возможность собирать поведение «из кубиков»
* уменьшение количества шаблонных параметров

**Пример ортогональных политик:**

* политика создания объекта (CreatePolicy)
* политика уничтожения (DestroyPolicy)
* политика синхронизации (ThreadingModel)

---

### Политики синхронизации в многопоточной среде

**Стратегии синхронизации:**

1. **Single-threaded** — без синхронизации.
2. **Mutex-based** — через std::mutex.
3. **Spinlock** — быстрая блокировка для коротких операций.
4. **Double-checked locking (DCLP)** — проверка и блокировка только при необходимости.

**Пример реализации политики с мьютексом:**

```cpp
struct MutexPolicy {
    std::mutex mtx;
    void lock() { mtx.lock(); }
    void unlock() { mtx.unlock(); }
};
```

**SpinLock Policy:**

```cpp
struct SpinLockPolicy {
    std::atomic_flag flag = ATOMIC_FLAG_INIT;
    void lock() {
        while (flag.test_and_set(std::memory_order_acquire)) {}
    }
    void unlock() {
        flag.clear(std::memory_order_release);
    }
};
```

---

### Паттерн Singleton с ортогональными стратегиями

**Составляющие:**

* Параметризированный класс `Singleton`
* Политика создания
* Политика уничтожения
* Политика синхронизации

**Пример:**

```cpp
template<typename T, typename ThreadingModel>
class Singleton {
public:
    static T& instance() {
        ThreadingModel::lock();
        static T instance;
        ThreadingModel::unlock();
        return instance;
    }
};
```

**Использование:**

```cpp
using MySingleton = Singleton<MyClass, MutexPolicy>;
MySingleton::instance().method();
```

---

### Легендарная библиотека **Loki**

Андрей Александреску в библиотеке **Loki** реализовал:

* Policy-based Singleton
* набор готовых политик (creation, threading, lifetime)
* универсальный подход для сборки сложных объектов

Примерная структура класса из Loki:

```cpp
template
<
    class T,
    class CreationPolicy,
    class LifetimePolicy,
    class ThreadingModel
>
class SingletonHolder;
```

---

## Практическая часть

**Задача:**
универсальный `Singleton` на базе ортогональных стратегий для многопоточной среды.

**Минимальный состав:**

* Политика синхронизации (Mutex, Spinlock, NoLock)
* Политика создания объекта (Static, Dynamic)
* Singleton-шаблон с параметрами

**Бонус:**
Unit Tests и сравнить производительность разных стратегий.

---
