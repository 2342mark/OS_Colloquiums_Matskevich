# Коллоквиум 1: Теоретические вопросы и практические задания

## Теоретическая часть

### WinAPI, необходимые для лабораторной работы №2

Для создания и управления процессами, потоками и синхронизацией в Windows используются следующие функции:

- `CreateProcess()` — создание нового процесса.
- `OpenProcess()` — открытие уже существующего процесса.
- `CreateThread()` — создание нового потока в процессе.
- `WaitForSingleObject()` — ожидание завершения потока или объекта.
- `WaitForMultipleObjects()` — ожидание нескольких объектов.
- `CreateSemaphore()` — создание семафора.
- `ReleaseSemaphore()` — освобождение ресурсов семафора.
- `InitializeCriticalSection()` — инициализация критической секции.
- `EnterCriticalSection()` — вход в критическую секцию.
- `LeaveCriticalSection()` — выход из критической секции.
- `DeleteCriticalSection()` — удаление критической секции.
- `CloseHandle()` — закрытие дескриптора объекта.

---

### Что такое процесс в ОС Windows

Процесс — это экземпляр выполняемой программы, обладающий собственным адресным пространством, системными ресурсами (файлами, дескрипторами, потоками) и уникальным идентификатором (PID). Каждый процесс может содержать один или несколько потоков.

---

### Что такое критическая секция

Критическая секция — это механизм синхронизации, обеспечивающий эксклюзивный доступ одного потока к разделяемому ресурсу. Применяется в рамках одного процесса и обладает высокой скоростью работы, так как выполняется на уровне пользовательского режима.

---

### Что такое семафор

Семафор — это объект синхронизации, позволяющий ограничить количество потоков, одновременно имеющих доступ к ресурсу. В отличие от критической секции может использоваться между разными процессами. Основан на счётчике доступных ресурсов.

---

### Сравнительный анализ C++98 с использованием Boost и современных стандартов с использованием Qt

| Параметр                | C++98 с Boost              | C++11/17 с Qt                 |
|:------------------------|:---------------------------|:------------------------------|
| Потоки                   | Boost.Thread                | std::thread / QtConcurrent     |
| Синхронизация            | Boost.Mutex, OS API          | std::mutex / QMutex            |
| Умные указатели          | boost::shared_ptr и др.      | std::shared_ptr, std::unique_ptr |
| Тестирование             | Boost.Test                   | Google Test / Qt Test          |
| Исключения               | try-catch, Boost.Exception   | стандартные исключения, сигналы Qt |

---

## Общие вопросы

### Что такое ООП

Объектно-Ориентированное Программирование (ООП) — это парадигма программирования, основанная на концепции **объектов**, которые объединяют данные и методы работы с ними. Принципы ООП:

- Инкапсуляция
- Наследование
- Полиморфизм
- Абстракция

---

### Магическое число 7 Миллера

Теория Миллера гласит, что средний человек способен одновременно удерживать в рабочей памяти от **5 до 9 элементов**. В ИТ это проявляется в:

- Количестве пунктов в меню
- Числе параметров функции
- Количестве одновременно открытых окон
- Количестве элементов на панели инструментов
- Ограничении уровней вложенности интерфейсов
- Количестве доступных режимов программы
- Количестве одновременных соединений

---

### Энтропия ПО

Энтропия ПО — это тенденция к усложнению и деградации структуры программы со временем. Меры против энтропии:

- Регулярные ревью кода
- Непрерывное тестирование
- Рефакторинг
- Анализ статическим анализатором
- Соблюдение единого стандарта кодирования

---

### 5 признаков сложной системы по Гради Бучу

| Признак        | Описание                     | Примеры                                |
|:---------------|:-----------------------------|:----------------------------------------|
| Иерархия        | Разделение системы на уровни  | Древовидная структура классов, модули ОС |
| Абстракция      | Скрытие внутренней сложности | Интерфейсы к модулям, шаблонные классы  |
| Инкапсуляция    | Ограничение доступа к данным | Закрытые поля классов, мьютексы         |
| Модульность     | Независимые компоненты       | Разделение кода на библиотеки          |
| Сложность       | Взаимосвязанные элементы     | Межпроцессное взаимодействие, IPC      |

---

### Закон иерархических компенсаций Седова

Согласно этому закону, развитие одной технологии компенсирует недостатки другой. Примеры:

1. Переход от пакетной обработки к многозадачности.
2. От процедурного программирования к ООП.
3. От одноядерных процессоров к многоядерным.
4. От HDD к SSD.
5. От локальных серверов к облачным платформам.

---

## Практическая часть

### Задачи

1. Вычислить первые `n` чисел Фибоначчи.
2. Определить, является ли число палиндромом.
3. Развернуть связный список итеративным способом.

Каждая задача должна быть реализована с:

- Обработкой исключений
- Полным покрытием юнит-тестами
- Оформлением по промышленным стандартам
- Сборкой через CMake
- Документированием кода и структуры проекта
